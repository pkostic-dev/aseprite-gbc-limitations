-- GBC Limitations Tool
-- Helps with managing GBC limitations
-- Analyzes Game Boy Color compatible palettes in tiles
-- Supports both image layers and tilemap layers
-- Script version 1.0

local TILE_SIZE = 8
local MAX_COLORS_PER_PALETTE = 4
local MAX_PALETTES_GBC = 8

local dlg = nil

-- ---------- Utilities ----------

-- Create a unique key for a color
local function colorKey(c)
  return string.format("%d,%d,%d,%d", c.red, c.green, c.blue, c.alpha)
end

-- Count the number of unique colors in a palette
local function paletteSize(palette)
  local count = 0
  for _ in pairs(palette) do
    count = count + 1
  end
  return count
end

-- Check if palette A is a subset of palette B
local function isSubset(paletteA, paletteB)
  for key in pairs(paletteA) do
    if not paletteB[key] then
      return false
    end
  end
  return true
end

-- Convert a palette table to a sorted array
local function paletteToArray(palette)
  local colors = {}
  for _, color in pairs(palette) do
    table.insert(colors, color)
  end
  -- Sort colors by brightness for consistent display
  table.sort(colors, function(a, b)
    local brightnessA = a.red + a.green + a.blue
    local brightnessB = b.red + b.green + b.blue
    return brightnessA < brightnessB
  end)
  return colors
end

-- Export palettes to a file
local function exportPalettes(validPalettes)
  local sprite = app.activeSprite
  if not sprite then return end

  local filename = app.fs.filePath(sprite.filename)
  if filename == "" then
    filename = "untitled"
  else
    filename = app.fs.fileTitle(filename)
  end

  local exportPath = app.fs.joinPath(
    app.fs.userConfigPath,
    filename .. "_palettes.gpl"
  )

  local file = io.open(exportPath, "w")
  if not file then
    app.alert("Could not create export file at: " .. exportPath)
    return
  end

  -- Write GPL header
  file:write("GIMP Palette\n")
  file:write("Name: " .. filename .. "_GBC_Palettes\n")
  file:write("# Generated by GBC Limitations Tool\n")
  file:write("# " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n")
  file:write("# Total Palettes: " .. #validPalettes .. "\n")
  file:write("#\n")

  -- Write all colors from all palettes
  for i, palette in ipairs(validPalettes) do
    local colors = paletteToArray(palette)
    file:write("# Palette " .. i .. " (" .. #colors .. " colors)\n")

    for _, color in ipairs(colors) do
      -- GPL format: R G B Name (tab-separated)
      file:write(string.format("%d\t%d\t%d\tPalette_%d\n",
        color.red, color.green, color.blue, i))
    end
  end

  file:close()
  app.alert("Palettes exported to GPL format:\n" .. exportPath)
end

-- Create a unique pattern key from tile pixel indices (color-agnostic)
local function getTilePattern(img, tx, ty)
  local pattern = {}
  local colorMap = {}
  local nextIndex = 1

  for y = 0, TILE_SIZE - 1 do
    for x = 0, TILE_SIZE - 1 do
      local pixelX = tx * TILE_SIZE + x
      local pixelY = ty * TILE_SIZE + y

      if pixelX < img.width and pixelY < img.height then
        local pixelValue = img:getPixel(pixelX, pixelY)
        local color = Color(pixelValue)

        if color.alpha > 0 then
          local key = colorKey(color)
          if not colorMap[key] then
            colorMap[key] = nextIndex
            nextIndex = nextIndex + 1
          end
          table.insert(pattern, colorMap[key])
        else
          table.insert(pattern, 0) -- Transparent
        end
      else
        table.insert(pattern, 0)
      end
    end
  end

  return table.concat(pattern, ",")
end

-- ---------- Analysis ----------

local function analyzeLayer(layer, frame)
  if not layer or (not layer.isImage and not layer.isTilemap) then
    return nil, "Invalid layer"
  end

  local cel = layer:cel(frame)
  if not cel then
    return nil, "No cel found in layer"
  end

  local img = cel.image
  local validPalettes = {}
  local overflowPalettes = {}
  local emptyTiles = 0
  local uniquePatterns = {}

  local isTilemap = layer.isTilemap
  local tileset = nil
  local tileWidth = TILE_SIZE
  local tileHeight = TILE_SIZE

  if isTilemap then
    tileset = layer.tileset
    if not tileset then
      return nil, "Tilemap has no tileset"
    end

    -- Get tile dimensions from the tileset grid
    local grid = tileset.grid
    if grid then
      tileWidth = grid.tileSize.width
      tileHeight = grid.tileSize.height
    end

    -- For tilemaps, the image dimensions represent the number of tiles, not pixels
    local tilesX = img.width
    local tilesY = img.height

    -- Analyze each tile position in the tilemap
    for ty = 0, tilesY - 1 do
      for tx = 0, tilesX - 1 do
        -- Get the tile index at this position
        local tileIndex = img:getPixel(tx, ty)

        -- Tile index 0 is the empty tile
        if tileIndex == 0 then
          emptyTiles = emptyTiles + 1
          goto continue
        end

        -- Get the actual tile from the tileset
        local tile = tileset:tile(tileIndex)
        if not tile or not tile.image then
          emptyTiles = emptyTiles + 1
          goto continue
        end

        -- Now analyze the colors in this tile's image
        local tileImage = tile.image
        local tileColors = {}

        -- Also generate color-agnostic pattern for this tile
        local pattern = {}
        local colorMap = {}
        local nextIndex = 1

        for y = 0, tileImage.height - 1 do
          for x = 0, tileImage.width - 1 do
            local pixelValue = tileImage:getPixel(x, y)
            local color = Color(pixelValue)

            if color.alpha > 0 then
              local key = colorKey(color)
              tileColors[key] = color

              -- Build color-agnostic pattern
              if not colorMap[key] then
                colorMap[key] = nextIndex
                nextIndex = nextIndex + 1
              end
              table.insert(pattern, colorMap[key])
            else
              table.insert(pattern, 0)  -- Transparent
            end
          end
        end

        local colorCount = paletteSize(tileColors)

        -- Skip empty tiles
        if colorCount == 0 then
          emptyTiles = emptyTiles + 1
          goto continue
        end

        -- Track unique patterns (color-agnostic)
        local patternKey = table.concat(pattern, ",")
        uniquePatterns[patternKey] = true

        -- Check if tile exceeds color limit
        if colorCount > MAX_COLORS_PER_PALETTE then
          table.insert(overflowPalettes, {
            colors = tileColors,
            x = tx + 1,
            y = ty + 1,
            pixelX = tx * tileWidth,
            pixelY = ty * tileHeight
          })
          goto continue
        end

        -- Try to merge with existing palettes
        local merged = false
        for i = #validPalettes, 1, -1 do
          local existingPalette = validPalettes[i]

          if isSubset(tileColors, existingPalette) then
            merged = true
            break
          end

          if isSubset(existingPalette, tileColors) then
            validPalettes[i] = tileColors
            merged = true
            break
          end

          local combinedPalette = {}
          for k, v in pairs(existingPalette) do
            combinedPalette[k] = v
          end
          for k, v in pairs(tileColors) do
            combinedPalette[k] = v
          end

          if paletteSize(combinedPalette) <= MAX_COLORS_PER_PALETTE then
            validPalettes[i] = combinedPalette
            merged = true
            break
          end
        end

        if not merged then
          table.insert(validPalettes, tileColors)
        end

        ::continue::
      end
    end

    -- Count unique patterns
    local uniquePatternCount = 0
    for _ in pairs(uniquePatterns) do
      uniquePatternCount = uniquePatternCount + 1
    end

    return {
      validPalettes = validPalettes,
      overflowPalettes = overflowPalettes,
      emptyTiles = emptyTiles,
      totalTiles = tilesX * tilesY,
      tilesX = tilesX,
      tilesY = tilesY,
      uniquePatternCount = uniquePatternCount
    }, nil

  else
    -- Regular image layer analysis
    local tilesX = math.floor(img.width / TILE_SIZE)
    local tilesY = math.floor(img.height / TILE_SIZE)

    -- Analyze each tile
    for ty = 0, tilesY - 1 do
      for tx = 0, tilesX - 1 do
        local tileColors = {}

        -- Sample all pixels in the tile
        for y = 0, TILE_SIZE - 1 do
          for x = 0, TILE_SIZE - 1 do
            local pixelX = tx * TILE_SIZE + x
            local pixelY = ty * TILE_SIZE + y

            -- Bounds check
            if pixelX < img.width and pixelY < img.height then
              local pixelValue = img:getPixel(pixelX, pixelY)
              local color = Color(pixelValue)

              -- Only count visible pixels
              if color.alpha > 0 then
                tileColors[colorKey(color)] = color
              end
            end
          end
        end

        local colorCount = paletteSize(tileColors)

        -- Skip empty tiles
        if colorCount == 0 then
          emptyTiles = emptyTiles + 1
          goto continue
        end

        -- Track unique tile patterns (color-agnostic)
        local pattern = getTilePattern(img, tx, ty)
        uniquePatterns[pattern] = true

        -- Check if tile exceeds color limit
        if colorCount > MAX_COLORS_PER_PALETTE then
          table.insert(overflowPalettes, {
            colors = tileColors,
            x = tx + 1,
            y = ty + 1,
            pixelX = tx * TILE_SIZE,
            pixelY = ty * TILE_SIZE
          })
          goto continue
        end

        -- Try to merge with existing palettes
        local merged = false
        for i = #validPalettes, 1, -1 do
          local existingPalette = validPalettes[i]

          -- Check if current tile's colors are subset of existing palette
          if isSubset(tileColors, existingPalette) then
            merged = true
            break
          end

          -- Check if existing palette is subset of current tile
          if isSubset(existingPalette, tileColors) then
            validPalettes[i] = tileColors
            merged = true
            break
          end

          -- Try to merge if combined palette doesn't exceed limit
          local combinedPalette = {}
          for k, v in pairs(existingPalette) do
            combinedPalette[k] = v
          end
          for k, v in pairs(tileColors) do
            combinedPalette[k] = v
          end

          if paletteSize(combinedPalette) <= MAX_COLORS_PER_PALETTE then
            validPalettes[i] = combinedPalette
            merged = true
            break
          end
        end

        if not merged then
          table.insert(validPalettes, tileColors)
        end

        ::continue::
      end
    end

    -- Count unique patterns
    local uniquePatternCount = 0
    for _ in pairs(uniquePatterns) do
      uniquePatternCount = uniquePatternCount + 1
    end

    return {
      validPalettes = validPalettes,
      overflowPalettes = overflowPalettes,
      emptyTiles = emptyTiles,
      totalTiles = tilesX * tilesY,
      tilesX = tilesX,
      tilesY = tilesY,
      uniquePatternCount = uniquePatternCount
    }, nil
  end
end

local function analyze(sprite, analyzeAllLayers)
  if not sprite then
    return nil, "No sprite provided"
  end

  -- Check if sprite has frames
  if #sprite.frames == 0 then
    return nil, "Sprite has no frames"
  end

  local frame = app.activeFrame or sprite.frames[1]

  if analyzeAllLayers then
    -- Analyze all visible image and tilemap layers
    local allValidPalettes = {}
    local allOverflowPalettes = {}
    local totalEmptyTiles = 0
    local totalTiles = 0
    local allUniquePatterns = {}
    local layerResults = {}

    for _, layer in ipairs(sprite.layers) do
      if layer.isVisible and (layer.isImage or layer.isTilemap) then
        local result, err = analyzeLayer(layer, frame)
        if result then
          table.insert(layerResults, {
            name = layer.name,
            result = result
          })

          -- Merge palettes across layers
          for _, palette in ipairs(result.validPalettes) do
            local merged = false
            for i = #allValidPalettes, 1, -1 do
              local existingPalette = allValidPalettes[i]

              if isSubset(palette, existingPalette) then
                merged = true
                break
              elseif isSubset(existingPalette, palette) then
                allValidPalettes[i] = palette
                merged = true
                break
              end

              local combinedPalette = {}
              for k, v in pairs(existingPalette) do
                combinedPalette[k] = v
              end
              for k, v in pairs(palette) do
                combinedPalette[k] = v
              end

              if paletteSize(combinedPalette) <= MAX_COLORS_PER_PALETTE then
                allValidPalettes[i] = combinedPalette
                merged = true
                break
              end
            end

            if not merged then
              table.insert(allValidPalettes, palette)
            end
          end

          -- Collect overflow palettes
          for _, overflow in ipairs(result.overflowPalettes) do
            overflow.layerName = layer.name
            table.insert(allOverflowPalettes, overflow)
          end

          totalEmptyTiles = totalEmptyTiles + result.emptyTiles
          totalTiles = totalTiles + result.totalTiles
        end
      end
    end

    if #layerResults == 0 then
      return nil, "No visible image layers found"
    end

    -- Count total unique patterns across all layers
    for _, layerData in ipairs(layerResults) do
      -- We'll use a simplified approach - just sum the patterns
      -- A more accurate approach would track patterns across layers
    end

    local totalPatternCount = 0
    for _, layerData in ipairs(layerResults) do
      totalPatternCount = totalPatternCount + layerData.result.uniquePatternCount
    end

    return {
      validPalettes = allValidPalettes,
      overflowPalettes = allOverflowPalettes,
      emptyTiles = totalEmptyTiles,
      totalTiles = totalTiles,
      tilesX = layerResults[1].result.tilesX,
      tilesY = layerResults[1].result.tilesY,
      layerName = "All Layers",
      uniquePatternCount = totalPatternCount,
      isMultiLayer = true,
      layerResults = layerResults
    }, nil
  else
    -- Single layer analysis
    local layer = app.activeLayer
    if not layer or not layer.isVisible then
      -- Find first visible layer
      for _, l in ipairs(sprite.layers) do
        if l.isVisible and (l.isImage or l.isTilemap) then
          layer = l
          break
        end
      end
    end

    if not layer then
      return nil, "No visible layer found"
    end

    local result, err = analyzeLayer(layer, frame)
    if err then
      return nil, err
    end

    result.layerName = layer.name
    result.isMultiLayer = false
    return result, nil
  end
end

-- ---------- UI ----------

local function buildDialog(results, errorMsg)
  if dlg then
    dlg:close()
  end

  dlg = Dialog {
    title = "GBC Limitations Tool",
    dockable = true
  }

  -- Analyze button
  dlg:button {
    id = "analyze_btn",
    text = "Analyze",
    focus = true,
    onclick = function()
      local sprite = app.activeSprite
      if not sprite then
        app.alert("No active sprite. Please open or create a sprite first.")
        return
      end

      local data, err = analyze(sprite, false)
      if err then
        app.alert("Error: " .. err)
        return
      end

      buildDialog(data, nil)
    end
  }

  -- Analyze All button (only show if multiple layers exist)
  local sprite = app.activeSprite
  if sprite then
    local visibleLayerCount = 0
    for _, layer in ipairs(sprite.layers) do
      if layer.isVisible and (layer.isImage or layer.isTilemap) then
        visibleLayerCount = visibleLayerCount + 1
      end
    end

    if visibleLayerCount > 1 then
      dlg:button {
        id = "analyze_all_btn",
        text = "Analyze All",
        onclick = function()
          local spr = app.activeSprite
          if not spr then
            app.alert("No active sprite.")
            return
          end

          local data, err = analyze(spr, true)
          if err then
            app.alert("Error: " .. err)
            return
          end

          buildDialog(data, nil)
        end
      }
    end
  end

  -- Export Palettes button (only show if we have results)
  if results and #results.validPalettes > 0 then
    dlg:button {
      id = "export_btn",
      text = "Export Palettes",
      onclick = function()
        exportPalettes(results.validPalettes)
      end
    }
  end

  dlg:separator()

  -- Display results if available
  if errorMsg then
    dlg:label {
      text = "Error: " .. errorMsg
    }
  elseif results then
    local validCount = #results.validPalettes
    local overflowCount = #results.overflowPalettes

    -- Summary section
    dlg:label {
      text = string.format("Layer: %s", results.layerName)
    }

    dlg:separator()

    dlg:label {
      text = string.format("Total tiles: %d", results.totalTiles)
    }

    dlg:label {
      text = string.format("Grid: %dx%d", results.tilesX, results.tilesY)
    }

    if results.emptyTiles > 0 then
      dlg:label {
        text = string.format("Empty tiles: %d", results.emptyTiles)
      }
    end

    dlg:separator()

    -- Palette count warning
    if validCount > MAX_PALETTES_GBC then
      dlg:label {
        text = string.format("Unique palettes: %d ⚠", validCount)
      }
      dlg:label {
        text = string.format(" (GBC limit: %d)", MAX_PALETTES_GBC)
      }
    else
      dlg:label {
        text = string.format("Unique palettes: %d", validCount)
      }
    end

    dlg:label {
      text = string.format("Unique patterns: %d", results.uniquePatternCount)
    }

    -- Overflow warning
    if overflowCount > 0 then
      dlg:label {
        text = string.format("Problem tiles: %d ⚠", overflowCount)
      }
    end

    dlg:separator()

    -- Display valid palettes
    if validCount > 0 then
      for i, palette in ipairs(results.validPalettes) do
        local colors = paletteToArray(palette)
        local colorCount = #colors

        dlg:separator {
          text = string.format("Palette %d (%d color%s)",
            i, colorCount, colorCount > 1 and "s" or "")
        }

        dlg:shades {
          id = "palette_" .. i,
          colors = colors,
          mode = "pick"
        }
      end
    end

    -- Display overflow palettes
    if overflowCount > 0 then
      dlg:separator {
        text = "Problem Tiles"
      }

      for i, tileData in ipairs(results.overflowPalettes) do
        local colors = paletteToArray(tileData.colors)
        local colorCount = #colors

        dlg:separator {
          text = string.format("Problem Tile %d", i)
        }

        if tileData.layerName then
          dlg:label {
            text = string.format("Layer: %s", tileData.layerName)
          }
        end

        dlg:label {
          text = string.format("Position: (%d, %d)", tileData.x, tileData.y)
        }

        dlg:label {
          text = string.format("Pixel: (%d, %d)", tileData.pixelX, tileData.pixelY)
        }

        dlg:label {
          text = string.format("%d colors ⚠", colorCount)
        }

        dlg:shades {
          id = "overflow_" .. i,
          colors = colors,
          mode = "pick"
        }
      end
    end
  else
    dlg:label {
      text = "Click 'Analyze' to check the active sprite"
    }
  end

  dlg:show { wait = false }
end

-- ---------- Start ----------

buildDialog(nil, nil)